%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%

classdef fbmc_chain < handle

    properties
        
        % fbmc parameter
        k;                  	% fbmc overlapping factor 
        prototype_filter;       % prototype filter function definition
        
        % frame form
        n_subc;                 % number of subchannels
        n_guard_l;              % number of subchannels deactivated at left spectrum edges
        n_guard_r;              % number of subchannels deactivated at right spectrum edges
        deac_DC;                % use DC for data transmission of not
        n_symbols;             	% number of complex symbols within one frame including ambles
        
        frame_len;              % length of frame after modulation
        
        % time domain filter
        filter_func;            % depends on k, prototype_filter and n_subc
        
        % interference generated by the ambiguity function
        ambiguity_interference;
        ambiguity_k_k_dot_diff;
        ambiguity_m_m_dot_diff;
        
        % amble design
        amble_pos;              % position of amble
        amble_len;              % length of amble in complex symbols: minimum=2 maximum=4
        amble_std;              % the vector over all subcarriers
        
        % modulation paramters
        M;                      % modulation order = 2, 4, 16, 64, 256, 1024 etc., always refers to QAM
        modulation_type;        % QAM or PAM
        constell_pam_norm;      % normalized PAM constellation diagramm
        constell_pam_norm_fac;  % normalization factor for PAM modulation
        
        % embedded pilot schemes
        pilots;
        pilots_amplitude_boost;	% each pilot has an average amplitude of 0.5, but this amplitude can be boosted
        
        % holes in the spectrum
        holes;
        
        % indices of all relevant d_k_m and frame complex points
        frame_data_indices;
        d_k_m_indices;
        d_k_m_data_indices;
        d_k_m_amble_indices;
        d_k_m_pilot_indices;
        d_k_m_statistics;
        
        % embedded pilot values
        pilots_val;
        pilots_val_pattern;
        
        % general coding
        encoding;               % encoder type
        numerator;           	% code rate
        denumerator;
        
        % bits counts at different stages
        n_bits_codable_blk_wish;    % number of codable bits in one block, wished value coming from LTE (e.g. 6144)
        n_bits_tx;                  % number of bits transmitted in one frame
        n_bits_coded_zeros;         % number of zeros appended to the encoded blocks
        n_blocks;                   % number of blocks we intend to transmit
        n_bits_coded_blk;           % number of coded bits per block
        n_bits_codable_blk;         % number of codable bits we will put in one block
        n_bits_user_zeros_blk;      % number of appended zeros to user bits
        n_bits_user_blk;            % number of user bits per block
        
        % convolutional coding
        convEncoder;            % convolutional encoder handle -> speeds up matlab
        vitDecoder;             % viterbi decoder handle -> speeds up matlab
        
        % interleaving
        block_interl_active;    % set to false, then bits will not be interleaved
        block_interl_pattern;   % indices of bits as they are swapped

        % equalization
        equalizer_type;         % 'ideal' or 'zeroforcing'
        interpol_ri_ma;         % interpolate real and imag part OR magnitude and angle
        measured_ch;            % measured channel, determined in equalizer by interpolation
        measured_ch_inv;    	% inverse of measured_ch
        perfect_ch;             % the exact channel values at each point in oqam_frame_rx
        
        % warping: Set warp_tx = warp_rx = false to completely deactivate warping.
        %
        %   Files that use warping variables:
        %       1) fbmc_chain.m
        %       2) frame_lib.patterns.m
        %       3) frame_lib.frame_comp.m
        %       4) equalizer_lib.equalize.m
        %       5) warp_lib.*
        %
        warp_tx;                % type of warping at transmitter
        warp_rx;                % type of warping at receiver
        warp_blk_f;             % we calculate CSI for groups of subcarriers
        warp_blk_t;             % we calculate CSI for groups of symbols
        warp_delay;             % how much symbols later does CSI arrive at the transmitter
        warp_fac;               % the warping factor, always calculated at receiver and used at transmitter
        
        % container tx
        user_bits;              % tx user bits (net)
        coded_bits;           	% tx coded bits (gross) -> not neccesarily transmitted bits (filled with 0)
        transmitted_bits;       % all transmitted bits
        frame;                  % complex frame with preamble included
        d_k_m;                  % frame seperated into real and imaginary part
        oqam_frame;             % oqam frame = d_k_m_j
        samples;                % time domain samples
        
        % container rx
        samples_rx;
        oqam_frame_rx;                  % received oqam frame = d_k_m_j
        oqam_frame_equ_rx;              % received oqam frame = d_k_m_j after equalization
        oqam_frame_equ_no_pattern_rx;	% received oqam frame = d_k_m_j after equalization without ReIm-pattern, before taking real part
        d_k_m_rx;
        frame_rx;
        transmitted_bits_rx;
        coded_bits_rx;
        user_bits_rx;
    end
    
    methods (Static = true, Access = public)
        
        % Constructor:
        %
        %   1) Set all properties that do not depend on other properties.
        %   2) Properties that depend on other properties are set in the reconfigure-function.
        %
        function obj = fbmc_chain()
            
            obj.k = 4;
            obj.prototype_filter = 'iota';

            obj.n_subc = 64;
            obj.n_guard_l = 10;
            obj.n_guard_r = 10;
            obj.deac_DC = false;
            obj.n_symbols = 104;
            
            obj.amble_pos = 'pre';
            obj.amble_len = 4;

            obj.M = 4;
            obj.modulation_type = 'PAM';
            
            obj.pilots_amplitude_boost = 1.0;
            
            obj.encoding = 'convolutional_7';
            obj.numerator = 1;
            obj.denumerator = 2;

            obj.n_bits_codable_blk_wish = inf;     % 768, 1536, 3072, 2*3*4*256 = 6144, 12288
            
            obj.block_interl_active = true; 

            obj.equalizer_type = 'perfect';	% none, amble, pilot, amble_pilot, perfect
            obj.interpol_ri_ma = 'ma';      % ri, ma 
            obj.measured_ch = [];
            obj.measured_ch_inv = [];
            obj.perfect_ch = [];
            
            obj.warp_tx = 'none';           % none, warp
            obj.warp_rx = 'none';           % none, measure, dewarp
            obj.warp_blk_f = 1;
            obj.warp_blk_t = 1;
            obj.warp_delay = 0;
            obj.warp_fac = [];
            
            % calculate all properties that depend on other properties
            obj.reconfigure();
        end
    end
    
    methods (Static = false, Access = public)

        %% recalculate everything if some of the parameters were changed
        function [] = reconfigure(self)
            
            self.frame_len = self.n_subc*(self.n_symbols + self.k);
            
            self.filter_func = fbmc_lib.filter_func_load(self.prototype_filter, self.n_subc, self.k);
            
            [self.ambiguity_interference, ...
                self.ambiguity_k_k_dot_diff, ...
                self.ambiguity_m_m_dot_diff] = fbmc_lib.ambiguity_interference(self, 2, 2, 1, 1);
            
            self.amble_std = frame_lib.amble_load(self);

            [self.constell_pam_norm, self.constell_pam_norm_fac] = frame_lib.constellation_pam_norm(self);
            
            self.pilots = [frame_lib.pattern_pilot(2, 5, 7, 6, self.modulation_type, [2]); ...
                            frame_lib.pattern_pilot(6, 2, 7, 6, self.modulation_type, [2])];
            
            self.holes = frame_lib.pattern_hole(ceil(self.n_symbols/4), self.n_symbols, self.n_subc/2+7, self.n_subc/4*4); ...
                            frame_lib.pattern_hole(ceil(self.n_symbols/4), self.n_symbols, self.n_subc/2+9, self.n_subc/4*4);

            [self.frame_data_indices, ...
                self.d_k_m_indices, ...
                self.d_k_m_data_indices, ...
                self.d_k_m_amble_indices, ...
                self.d_k_m_pilot_indices, ...
                self.d_k_m_statistics] = frame_lib.patterns(self);
            
            if numel(self.pilots) > 0
                [self.pilots_val, self.pilots_val_pattern] = frame_lib.pilot_values(self);
            end
            
            [self.n_bits_tx, ...
                self.n_bits_coded_zeros, ...
                self.n_blocks, ...
                self.n_bits_coded_blk, ...
                self.n_bits_codable_blk, ...
                self.n_bits_user_zeros_blk, ...
                self.n_bits_user_blk] = frame_lib.bits_count(self);

            % convolutional coding with constraint length of 7
            [self.convEncoder,self.vitDecoder] = coding_lib.coder_init(self);
            
            % define an interleaving pattern that is applied after coding
            self.block_interl_pattern = coding_lib.interleaving_pattern(self);
                                    
            % do not reset warp factor
            self.warp_fac = self.warp_fac;
            
            % container tx
            self.user_bits          = [];
            self.coded_bits         = [];
            self.transmitted_bits   = [];
            self.frame              = [];
            self.d_k_m              = [];
            self.oqam_frame         = [];
            self.samples            = [];

            % container rx
            self.samples_rx                     = [];
            self.oqam_frame_rx                  = [];
            self.oqam_frame_equ_rx              = [];
            self.oqam_frame_equ_no_pattern_rx   = [];
            self.d_k_m_rx                       = [];
            self.frame_rx                       = [];
            self.transmitted_bits_rx            = [];
            self.coded_bits_rx                  = [];
            self.user_bits_rx                   = [];
        end
        
        %% function for creating a single frame
        function frame_samples = generate_frame(self)
            
            self.user_bits = frame_lib.bits_user_gen(self);
            self.coded_bits = coding_lib.encode(self);
            [self.frame, self.d_k_m, self.transmitted_bits] = frame_lib.frame_comp(self);
            self.oqam_frame = fbmc_lib.oqam_frame_comp(self);
            
            % the fftshift is applied here
            self.samples = fbmc_lib.modulation(self);
            
            % final samples
            frame_samples = self.samples;
        end
        
        %% function to restore a frames with channel matrix for specific user bits
        function frame_samples = generate_frame_restored(self, user_bits, correction_sync_stage)
            
            % set external user bits
            self.user_bits = user_bits;
            
            % perform the actual modulation
            self.coded_bits = coding_lib.encode(self);
            [self.frame, self.d_k_m, self.transmitted_bits] = frame_lib.frame_comp(self);
            self.oqam_frame = fbmc_lib.oqam_frame_comp(self);

            % now put the channel onto the samples
            self.oqam_frame = self.oqam_frame.*self.measured_ch;
            
            % the fftshift is applied here
        	self.samples = fbmc_lib.modulation(self);
            
            % final samples
            frame_samples = self.samples;
            
            % now put the correction on the samples that comes from sync stage
            if numel(correction_sync_stage) > 0
                frame_samples = frame_samples.*correction_sync_stage;
            end
        end 

        %% function for decoding a single frame
        function decode_frame(self, samples_ant, channel_handle)
            
            % SECURITY
            if numel(samples_ant) ~= numel(self.samples)
                error('The received frame for decoding it not as long as the frame generated.');
            end
            
            % before even starting the demodulation, we can calculate the exact channel influence on our frame in frequency domain
            self.perfect_ch = equalizer_lib.perfect_ch_knowledge(self, channel_handle);
           
            % save a copy of the received samples
            self.samples_rx = samples_ant;
            
            % the fft shift is applied here
            self.oqam_frame_rx = fbmc_lib.demodulation(self);
            
            [self.oqam_frame_equ_rx, self.measured_ch, self.measured_ch_inv, self.warp_fac] = equalizer_lib.equalize(self);
            [self.frame_rx, self.oqam_frame_equ_no_pattern_rx] = fbmc_lib.oqam_frame_decomp(self);
            [self.coded_bits_rx, self.transmitted_bits_rx, self.d_k_m_rx] = frame_lib.frame_decomp(self);
            self.user_bits_rx = coding_lib.decode(self);
        end
        
        %% measure the error of the user bits
        function [user_bit_rate, user_bit_rate_bpshz] = check_user_bit_rate(self)
            
            % how many bits do we transmit per second
            user_bit_rate = numel(self.user_bits)/numel(self.samples);
            
            % we only use parts of the spectrum, this has to be considered
            user_bit_rate_bpshz = user_bit_rate*numel(self.d_k_m_indices.pos_f)/numel(self.d_k_m_data_indices.lin);            
        end        
        
        %% function to check if the transmitted bits are equal
        function [transmitted_bit_errors, BER] = check_transmitted_bit_errors(self)
            transmitted_bit_errors = self.transmitted_bits - self.transmitted_bits_rx;
            transmitted_bit_errors = find(transmitted_bit_errors);
            BER = numel(transmitted_bit_errors)/numel(self.transmitted_bits);
        end
        
        %% function to check if the used bits are equal
        function [user_bit_errors, BER_user] = check_user_bit_errors(self)
            user_bit_errors = self.user_bits - self.user_bits_rx;
            user_bit_errors = find(user_bit_errors);
            BER_user = numel(user_bit_errors)/numel(self.user_bits);
        end
        
        %% function to check if the blocks are equal
        function [block_errors, BLER_user, throughput, throughput_bpshz] = check_block_errors_throughput(self)
            
            % reshape both user bit arrays to block size
            user_bits_blk = reshape(self.user_bits, self.n_bits_user_blk, self.n_blocks);
            user_bits_rx_blk = reshape(self.user_bits_rx, self.n_bits_user_blk, self.n_blocks);
            
            % calculate difference
            block_errors = user_bits_blk - user_bits_rx_blk;
            
            % calculate the sum over each block -> corresponds to the number of incorrect bits
            block_errors = sum(abs(block_errors),1);
            
            % find blocks with non zero values
            block_errors = find(block_errors);
            BLER_user = numel(block_errors)/self.n_blocks;
            
            %%% throughput
            
            % calculate number of successfully transmitted bits in blocks
            n_bits_successful_over_full_frame = (self.n_blocks - numel(block_errors))*self.n_bits_user_blk;
            
            % we have an assumed sampling rate of T=1, so divide by total length in seconds
            throughput = n_bits_successful_over_full_frame/numel(self.samples);
            
            % We only use parts of the spectrum, this has to be considered.
            % In the case of BPSK only one half of the d_k_m points can be used for data transmission.
            if self.M == 2
                usable_d_k_m_points = numel(self.d_k_m_indices.pos_f)/2;
            elseif self.M > 2
                usable_d_k_m_points = numel(self.d_k_m_indices.pos_f);
            end
            throughput_bpshz = throughput*usable_d_k_m_points/numel(self.d_k_m_data_indices.lin);
        end
        
    end 
end